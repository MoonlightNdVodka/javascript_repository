{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;AAAA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,0BAA0B,QAAQ;AAClC,8DAA8D,EAAE;AAChE;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA,4CAA4C,KAAK,QAAQ,KAAK;AAC9D,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG,iBAAiB,gBAAgB;AACvE;AACA,SAAS;AACT,mCAAmC,KAAK,iBAAiB,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,oBAAoB,UAAU,kBAAkB,QAAQ;AAC1G,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,WAAW;AACX,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU,UAAU,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,sBAAsB;AACtB,IAAI;AACJ;AACA,wBAAwB,GAAG;AAC3B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,IAAI,IAAI,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,EAAE,cAAc,SAAS,UAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACY;AACZ;AACO;AACP;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;;;;;;UC3sCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AACD;AAC/B;AACA,kBAAkB,OAAO,MAAM,IAAI;AACnC,eAAe,sCAAQ,EAAE,MAAM,sCAAQ,CAAC;AACxC,wCAAU;AACV;AACA;AAC8B;AAC9B,iDAAQ,G","sources":["webpack:///./src/js/main.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/js/script.js"],"sourcesContent":["// \"use strict\"; //режим современного \"строгого\" кода\r\n// const personalMovieDB = {\r\n//     count: 0,\r\n//     movies: {},\r\n//     actors: {},\r\n//     geners: [],\r\n//     privat: false,\r\n\r\n//     rememberMyFilms: function  () {\r\n//         for(let i = 0; i < 2; i++){\r\n\r\n//             const a = prompt(\"Один из последних просмотренных фильмов?\", \"\"),\r\n//             b = prompt(\"На сколько оцените его\", \"\");\r\n\r\n//             if (a != null && b != null && a != \"\" && b != \"\" && a.length < 30 ) {\r\n//             personalMovieDB.movies[a] = b;  \r\n//             } else {\r\n//                 i--;\r\n//             }\r\n//         }\r\n//     },\r\n\r\n//     start: function () {\r\n//         personalMovieDB.count = +prompt(\"Сколько фильмов уже посмотрели?\", \"\");\r\n//         while (personalMovieDB.count == \"\" || personalMovieDB.count == null || isNaN(personalMovieDB.count)){\r\n//             personalMovieDB.count = +prompt(\"Сколько фильмов уже посмотрели?\", \"\");\r\n\r\n//         }\r\n//     },\r\n\r\n//     detectPersonalLevel: function () {\r\n//         if (personalMovieDB.numberOfFilms < 10) {\r\n//             alert (\"Просмотрено довольно мало фильмов\");\r\n//            } else if (personalMovieDB.numberOfFilms >=10 && personalMovieDB.numberOfFilms <= 30) {\r\n//                alert (\"Вы классический зритель\");\r\n//            } else if (personalMovieDB.numberOfFilms > 30) {\r\n//                alert (\"Вы киноман\");\r\n//            } else {\r\n//                alert (\"Произошла ошибка\");\r\n//            }\r\n//     },\r\n//     showMyDB: function  (hidden){\r\n//         if (!hidden ){\r\n//             console.log (personalMovieDB);\r\n//         }\r\n//     },\r\n\r\n//     writeYourGenres: function  () {\r\n//         for(let i = 1; i <= 3; i++){\r\n//         let genre = prompt(`Ваш любимый жанр под номером ${i}`,\"\");\r\n//             if(genre == \"\" || genre == null) {\r\n//                 i--;\r\n//                 continue;\r\n//             } else {personalMovieDB.geners[i - 1 ] = genre;}\r\n//         }\r\n//         personalMovieDB.geners.forEach((item, i )=> {\r\n//             console.log(`Любимый жанр №${i+1} - это ${item}`);\r\n//         });\r\n\r\n//     },\r\n//     toggleVisibleMyDB: function () {\r\n//         if (personalMovieDB) {\r\n//             personalMovieDB.privat = false;\r\n//         } else {\r\n//             personalMovieDB.privat = true;\r\n//         }\r\n//     } \r\n\r\n// };\r\n\r\n\r\n// //FUNCTION DECLARATION \r\n// // //функции созданные таким образом существуют еще до того, как код начнет свое дейсвтие,\r\n// // т.к скрипт первым делом подгрузит все функции и var-ы, а потом начнет свою работу\r\n// // мы можем вызывать такие функции еще до того, как они будут обьявлены в коде \r\n// getUser();\r\n\r\n//  function getUser() {\r\n//     let gleb = 'User_Gleb';\r\n//   console.log(gleb);\r\n// }\r\n// // FUNCTION EXPRESSION\r\n// // функции, обьявленные таким образом, могут быть вызваны только после их обьявления\r\n// // myFunc();\r\n// const myFunc = function getUser() {\r\n//   let mark = 'User_Mark';\r\n// console.log(mark);\r\n// };\r\n// myFunc();\r\n// //СТРЕЛОЧНЫЕ ФУНКЦИИ\r\n// // такие функции не имеют своего контекста вызова\r\n// const calc = (a, b) =>  a + b;\r\n//  console.log(calc(1,5));\r\n\r\n\r\n\r\n// // CALLBACK функции, при их обьявлении, \r\n// // выполняются строго после определенных действий, \r\n\r\n// function learnJS(lang, callback) {\r\n//     console.log(`I'm learn: ${lang} `);\r\n//  //тут мы вызываем колбэк функцию, которая будет передана аргументом при вызове функции выше\r\n//     callback();\r\n\r\n// }\r\n// function done() {\r\n//     console.log('I complete this lesson!');\r\n// }\r\n\r\n// //здесь мы при вызове функции \"learnJS\" передаем аргументом функции другую функцию \"done\",\r\n// //  которая передается в аргумент и становится callback-функцией\r\n// learnJS('JavaScript', done);\r\n\r\n// const options = {\r\n//    name: 'test',\r\n//    width: 1024,\r\n//    height: 1125,\r\n//    colors: {\r\n//        border: 'black',\r\n//        bg: 'red'\r\n//    },\r\n//     makeTest: function (){\r\n//         console.log(\"Эта функция работает внутри обьекта\");\r\n//    }\r\n// };\r\n\r\n// options.makeTest();\r\n\r\n// //ДЕСТРУКТУРИЗАЦИЯ ОБЬЕКТА \r\n// const {border, bg} = options.colors; \r\n// console.log(border);\r\n\r\n\r\n// for (let key in options) {\r\n//     if (typeof (options[key]) === 'object') {\r\n//         for (let i in options[key]) {\r\n//         console.log(`Свойство ${i} имеет значение ${options[key][i]}`);\r\n//         }\r\n//     } else {\r\n//         console.log(`Свойство ${key} имеет значение ${options[key]}`);\r\n\r\n//     }\r\n// }\r\n\r\n// //Позволяет собирать значения ключей объекта в отдельный массив \r\n// console.log(Object.keys(options));\r\n\r\n\r\n// const arr = [ 2, 4, 5, 7, 10];\r\n\r\n// arr.forEach(function(arrValue, arrIndex, arrLink) {\r\n//     console.log(`Индекс элемента: ${arrIndex}; Значение элемента:${arrValue} внутри массива: ${arrLink}`);\r\n// });\r\n\r\n\r\n// // ПЕРЕДАЧА ПО ССЫЛКЕ, ГЛУБОКОЕ  И ПОВЕРХНОСТНОЕ КОПИРОВАНИЕ ОБЪЕКТОВ\r\n\r\n// function copy(mainObj) {\r\n//     //эта функция реализует поверхностное копирование обьекта,\r\n//     //если в копируемом обьекте будет свойство массив или обьект,\r\n//     //то это свойство не скоприруется,  \r\n//     //а создастся ссылка на это свойство в исходном обьекте\r\n//     let objCopy = {};\r\n\r\n//     let key;\r\n//     for (key in mainObj) {\r\n//         objCopy[key] = mainObj[key];\r\n//     }\r\n//     return objCopy;\r\n// }\r\n\r\n// const numbers = {\r\n//     a: 2,\r\n//     b: 5,\r\n//     c: {\r\n//         x: 7,\r\n//         y: 4\r\n//     }\r\n// };\r\n\r\n// const newNumbers = copy(numbers);\r\n\r\n// newNumbers.a = 10;\r\n// newNumbers.c.x = 10;\r\n// //при изменении вложенного массива или обьекта в новом скопированном обьекте, \r\n// // мы изменяем его везде, т.е и в исходном обьекте тоже,\r\n// //  т.к изменение происходит по ссылке\r\n\r\n// // console.log(newNumbers);\r\n// // console.log(numbers);\r\n\r\n// const add = {\r\n//     b: 31,\r\n//     h: 4\r\n// };\r\n\r\n// //создаст поверхностную копию обьектов \"NUMBERS, ADD\", И запишет их в \"Clone\"\r\n// const clone = Object.assign({numbers}, add);\r\n// console.log(clone);\r\n\r\n\r\n// const oldArray = ['a', 'b', 'c'];\r\n// //slice - позволит создать новую поверхностную копию массива\r\n// const newArray = oldArray.slice();\r\n\r\n// newArray[1] = 'Aboba';\r\n\r\n// console.log(newArray);\r\n// console.log(oldArray); \r\n\r\n\r\n// // SPREAD оператор: \"...\" вытаскивает элементы из массивов или обьектов \r\n// const video = ['youtube', 'vimeo', 'rutube'],\r\n//       blogs = ['wordpress', 'livejournal', 'blogger'],\r\n//       internet = [...video, ...blogs, 'vk', 'facebook'];\r\n\r\n//       console.log(internet);\r\n\r\n// //Раскрытие обьекта и вставка в функцию через SPREAD \r\n// function logs(a, b, c) {\r\n// console.log(a);\r\n// console.log(b);\r\n// console.log(c);\r\n// }\r\n\r\n// const numb = [1, 5, 8];\r\n// logs(...numb);\r\n\r\n// //копирование массивов через SPREAD\r\n// const arr1 = [1, 5, 7];\r\n// const arr2 = [...arr1];\r\n// console.log(arr2);\r\n\r\n// //копирование обьектов через SPREAD\r\n// const obj1 = {\r\n//     one: 4,\r\n//     two: 52,\r\n//     three: 17\r\n// };\r\n// const obj2 = {...obj1};\r\n// console.log(obj2);\r\n\r\n// // ООП, можно сказать что JS это прототипно-ориентированный язык.\r\n// //В нем обьекты наследуют свойства от прототипов\r\n// const solder = {\r\n//     health: 400,\r\n//     armor: 100,\r\n//     sayHi: function() {\r\n//         console.log(\"HELLO SIR!\");\r\n//     }\r\n// };\r\n\r\n// //мы создали обьект Джон, он пока не наследует ничего\r\n// const john = {\r\n//     health: 100\r\n// };\r\n// console.log(john);\r\n\r\n// // Тут можно увилить как Джон наследует свойство брони от обьекта Солдат\r\n// Object.setPrototypeOf(john, solder);\r\n// console.log(john.armor);\r\n\r\n// //Тут мы сразу создаем обьект Майк который наследует прототип Соладат\r\n// const mike = Object.create(solder);\r\n// mike.sayHi();\r\n\r\n\r\n\r\n// // Какое будет выведено значение: let x = 5; alert( x++ ); ?   \r\n// //   ОТВЕТ: 5 выведет, а потом увеличит до 6    \r\n\r\n// // // Чему равно такое выражение: [ ] + false - null + true ?    \r\n// // ОТВЕТ:[] пустой массив конвертируется в пустую строку: \"\", \r\n// // Затем строка складывается с false \r\n// // и получается строка \"false\", при сложении Этого с null и true ПОЛУЧАЕМ:  NaN  \r\n\r\n// // // Что выведет этот код: let y = 1; let x = y = 2; alert(x); \r\n// //  ОТВЕТ:  2, послед-е присваивание с права на лево                                  \r\n\r\n// // // Чему равна сумма [ ] + 1 + 2?                              \r\n// // ОТВЕТ: 12,  пустая строка + \"1\" + \"2\"\r\n\r\n// // // Что выведет этот код: alert( \"41\"[0] )?\r\n// //  ОТВЕТ:  4 - выводит элемент строки с 0 индексом - а это и есть 4,               \r\n\r\n// // // Чему равно 2 && 1 && null && 0 && undefined ?              \r\n// // ОТВЕТ:  null, ПОТОМУ ЧТО ОПЕРАТОР \"&&\"\" запинается на лжи,\r\n// //  как только он встречает null проверка дальше прекращается, С ОПЕРАТОРОМ \"||\" ИНАЧЕ\r\n// // ОН ОСТАНОВИТСЯ ПРИ ПЕРВОМ ЖЕ ИСТИННОМ ЗНАЧЕНИИ                  \r\n\r\n// // // Есть ли разница между выражениями? !!( a && b ) и (a && b) \r\n// // ОТВЕТ: есть, в 1 случае это будет булиновое значение из-за \"!!\"                             \r\n\r\n// // // Что выведет этот код: alert( null || 2 && 3 || 4 ); ?      \r\n// // ОТВЕТ:  3, по приоритету первым проверится оператор \"И\", дальше слева на право пойдут \r\n// // операторы \"ИЛИ\",                          \r\n\r\n// // // a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?       \r\n// // ОТВЕТ: нет, хоть и значения в массивах равны, сами массивы - это разные хранилища информации\r\n// // и они по определению не могут быть одинаковы, т.к мы не сравниваем именно их содержание                          \r\n\r\n// // // Что выведет этот код: alert( +\"Infinity\" ); ?              \r\n// // ОТВЕТ:    Infinity с типом данных number                \r\n\r\n// // // Верно ли сравнение: \"Ёжик\" > \"яблоко\"?                     \r\n// // ОТВЕТ: нет, false - нужно смотреть юникод            \r\n\r\n// // // Чему равно 0 || \"\" || 2 || undefined || true || falsе ?    \r\n// // ОТВЕТ: 2, 0 в лог-м контексте это falsе. \"\" тоже falsе, 2 - true, оператор или остановится на 2                        \r\n\r\n\r\n//ВСЕ ЭТИ ОБЬЕКТЫ ЭТО ПСЕВДО-ЭЛЕМЕНТЫ, ДЛЯ НИХ НЕТ МЕТОДОВ\r\n// //получает элемент по его ID\r\n// const box = document.getElementById('box');\r\n// console.log(box);\r\n\r\n// //получает ВСЕ элементы по их тэгу, записывая как коллекцию обьектов\r\n// const buttons = document.getElementsByTagName('button');\r\n// console.log(buttons);\r\n\r\n// //получает ВСЕ элементы по имени их класса, записывая как коллекцию обьектов\r\n// const circles = document.getElementsByClassName('circle');\r\n// console.log(circles);\r\n\r\n// //получает ВСЕ элементы по их названию из всей коллекции обьектов записывая их в массив\r\n// //для этого метода доступен перебор через forEach\r\n// const hearts = document.querySelectorAll('.heart');\r\n// hearts.forEach(key=> {\r\n//     console.log(key);    \r\n// });\r\n\r\n// //получает первый найденный элемент по его названию\r\n// const myHeart = document.querySelector('button');\r\n// console.log(myHeart);\r\n\r\n// const box = document.getElementById('box'),\r\n//       btns = document.getElementsByTagName ('button'),\r\n//       circles = document.getElementsByClassName('circle'),\r\n//       wrapper = document.querySelector('.wrapper'),\r\n\r\n//       //если у нас уже есть родитель \"wrapper\", то мы можем заменить\r\n//     // обращение с document на wrapper\r\n//       hearts = wrapper.querySelectorAll('.heart'),\r\n//       onrHeart = wrapper.querySelector('.heart');\r\n\r\n//       box.style.backgroundColor = 'green';\r\n//       box.style.width = '300px';\r\n\r\n//       box.style.cssText = 'background-color: brown; width: 370px';\r\n\r\n//       btns[1].style.borderRadius = '10 0%';\r\n//       //т.к это псевдо-массивы, обращаться нужно только к конкретному айди, \r\n//       //обращение ко всему массиву сразу не сработает\r\n//       circles[0].style.backgroundColor = \"yellow\";\r\n\r\n//     hearts.forEach(item => {\r\n//         item.style.backgroundColor = 'blue';\r\n//     });\r\n\r\n//     //СОЗДАЕТ элемент, но только внутри js, извне js его не изменить\r\n// const div = document.createElement('div');\r\n// div.classList.add('black');\r\n// //СОЗДАЕТ новый блок в начале класса  wrapper\r\n// wrapper.append(div);\r\n// //СОЗДАЕТ блок в конце класса wrapper\r\n// // wrapper.prepend(div);\r\n// // СОЗДАЕТ блок (до/после) конкретного эл.\r\n// // hearts[2].before(div);\r\n// //УДАЛЯЕТ определенный элемент в верстке\r\n// // circles[0].remove();\r\n// //ЗАМЕНЯЕТ элементы из одного блока, другим \r\n// hearts[0].replaceWith(circles[0]);\r\n// //позволяет вставлять как обычный текст в блок, так и \r\n// // html элементы внутрь блока \r\n// div.innerHTML = \"<h1>Hello:)</h1>\";\r\n// //помещает внутрь блока текст\r\n// // div.textContent = 'Hello!';\r\n// //позволяет вставить кусок html кода до/после элемента вначале или в конце\r\n// div.insertAdjacentHTML(\"beforebegin\", '<h2>Hey!</h2>');\r\n\r\n\r\n// ОБРАБОТЧИКИ СОБЫТИЙ \r\n// const btns = document.querySelectorAll('button');\r\n// const overlay = document.querySelector('.overlay');\r\n\r\n// // btn.onclick = function() {\r\n// //     alert('Click');\r\n// // };//не совсем верный способ реализации, удалить его нельзя\r\n// // при повторении кода действие перезапишется  \\\\\r\n\r\n// btns.addEventListener('click', () => {\r\n//   // alert('Clic1k');\r\n// });\r\n// // btn.addEventListener('mouseenter', () => {\r\n// //   alert ('Clic2k');\r\n// // });\r\n// // event - обьекты события \r\n// //ВАЖНО!! event-ы передаются как аргументы в callback функцию\r\n\r\n// //\r\n// let i = 0;\r\n// const deleteElement = (element) => {\r\n//   console.log(element.currentTarget);\r\n//   console.log(element.type);\r\n\r\n//   // i++;\r\n\t\r\n//   // if(i==1){\r\n//   // // удаление эвента\r\n//   // btn.removeEventListener('click', deleteElement);\r\n//   // }\r\n//   // element.target.remove();\r\n// };\r\n\r\n// //Всплытие событий - это когда обработчик событий идет\r\n// // от активного элемента выше по DOM-дереву\r\n\r\n// //Удаление обработчика с элемента по клику\r\n// // btn.addEventListener('click', deleteElement);\r\n// // overlay.addEventListener('click', deleteElement);\r\n\r\n//  btns.forEach(btn =>  {\r\n//    //Самый правильный спопоб вешать одинаковые обработчики событий на несколько \r\n//    //одинаковых элементов сразу. Т.к у querySelectorAll получаемые элементы это ПСЕВДОМАССИВ,\r\n// его мы можем использовать только перебирая каждый элемент через forEach\r\n//      btn.addEventListener('click', deleteElement);\r\n//  });\r\n\r\n// const link = document.querySelector('a');\r\n// console.log(link);\r\n\r\n// link.addEventListener('click', function(event) {\r\n\r\n//   //метод \"preventDefault\" отменяет стандартное поведение элемента на странице, \r\n//   // и применяет к нему поведение, которое указано будет ниже\r\n//     event.preventDefault();\r\n\r\n//     console.log(event.target);\r\n// });\r\n\r\n\r\n//НАВИГАЦИЯ ПО DOM дереву\r\n\r\n// console.log(document.head);\r\n// console.log(document.documentElement);\r\n\r\n// функция childNodes позволяет получить все элементы(ноды), которые находятся внутри родителя\r\n// console.log(document.body.childNodes);\r\n// console.log(document.body.firstChild);\r\n// console.log(document.body.firstElementChild);\r\n// console.log(document.body.lastChild);\r\n\r\n//parentNode выведет родительский элемент, в котором querySelector нашел обьект\r\n// console.log(document.querySelector('#current').parentNode.parentNode);\r\n// console.log(document.querySelector('#current').parentNode.parentElement);\r\n\r\n\r\n//  DATA-АТРИБУТЫ\r\n\r\n// что бы получить какой-либо атрибут html, мы ставим \"[ ]\"\r\n// console.log(document.querySelector('[data-current=\"3\"]').nextElementSibling);\r\n\r\n\r\n//У каждой ноды есть свое nodeName, если в этом условии нода будет с именем текста, мы пропустим ее показ\r\n// for (let node of document.body.childNodes) {\r\n\r\n//   if (node.nodeName == '#text') {\r\n//     continue;\r\n//   }\r\n//   if (node.nodeName == '#comment') {\r\n//     continue;\r\n//   }\r\n//   console.log(node);\r\n// }\r\n\r\n//СОБЫТИЯ НА МОБИЛЬНЫХ УСТРОЙСТВАХ\r\n\r\n //touchstart\r\n //touchmove\r\n //touchend\r\n //touchenter - как только палец зашел на пределы этого элемента \r\n //touchleave - как только палец ушел с пределов этого элемента\r\n //touchcancel  - точка соприкосновения больше не регистрируется на окне браузера\r\n\r\n// window.addEventListener('DOMContentLoaded', () => {\r\n// \tconst box = document.querySelector('.box');\r\n\r\n// \tbox.addEventListener('touchstart', (e) => {\r\n// \t\te.preventDefault();\r\n// \t\tconsole.log('Start');\r\n// \t\tconsole.log(e.targetTouches);\r\n// \t});\r\n\r\n// \tbox.addEventListener('touchmove', (e) => {\r\n// \t\te.preventDefault();\r\n// \t\tconsole.log(e.targetTouches[0].pageX);\r\n// \t});\r\n\r\n// \tbox.addEventListener('touchend', (e) => {\r\n// \t\te.preventDefault();\r\n// \t\tconsole.log('End');\r\n// \t});\r\n\r\n// \t//Hammer.js - скрипт для добавления моб-го функционала\r\n\r\n// \t//touches - кол-во пальцев на экране\r\n// \t//targetTouches\r\n// \t//changedTouches - содержит список пальцев, котопый был убран\r\n// });\r\n\r\n\r\n// АССИНХРОННОСТЬ\r\n\r\n///* <script defer src=\"./js/script.js\"></script> */\r\n// defer - говорит компилятору загружать скрипт в фоне, вместе с версткой не ожидая дозагрузки страницы\r\n// - такие скрипты будут всегда дожидаться полной дозагрузки ДОМ дерева html что бы начать выполнение\r\n\r\n///* <script async src=\"./js/script.js\"></script> */\r\n// async - загужается так же в фоне, не ожидая дозагрузки, но начнет выполнятся как только загрузится сам,\r\n//не дожидаясь полной прогрузки ДОМ дерева\r\n\r\n// const p = document.querySelectorAll('div');\r\n// console.log(p); \r\n\r\n// function loadScript(src) {\r\n// \tconst script = document.createElement('script');\r\n// \tscript.src = src;\r\n\r\n// \t//за счет отключенной ассинхронности, они будут выполняться друг за другом\r\n// \tscript.async = false;\r\n// \tdocument.body.append(script);\r\n// }\r\n\r\n// loadScript(\"js/test.js\");\r\n// loadScript(\"js/some.js\");\r\n\r\n\r\n//CLASS LIST и ДЕЛЕГИРОВАНИЕ СОБЫТИЙ \r\n\r\n// const btns = document.querySelectorAll('button');\r\n// const wrapper = document.querySelector ('.btn-block');\r\n\r\n// console.log(btns[0].classList);\r\n\r\n// // console.log(btns[0].classList.length);\r\n// // console.log(btns[0].classList.item(0));\r\n// // console.log(btns[1].classList.add('red', 'green'));\r\n// // console.log(btns[0].classList.remove('blue'));\r\n\r\n// // переключает классы, если класс такой есть - удаляет его с ээлемента\r\n// // если такой класс отсутствует в элементе - добавляет \r\n// // console.log(btns[0].classList.toggle('blue'));\r\n// // console.log(btns[0].classList.item(0));\r\n\r\n// // if (btns[1].classList.contains('red')) {\r\n// //     console.log ('red!!');\r\n// // }ф\r\n\r\n// btns[0].addEventListener('click', () => {\r\n//     // if (!btns[1].classList.contains('red')) {\r\n//     //     btns[1].classList.add('red');\r\n//     // } else {\r\n//     //     btns[1].classList.remove('red');\r\n//     // }\r\n\r\n//     //делает то же самое\r\n//     btns[1].classList.toggle('red');\r\n// });\r\n\r\n// //выводит имена всех классов элемента в одну строчку\r\n// console.log(btns[0].className);\r\n\r\n// // делегирование - разграничение действий на определенных элементах \r\n// // в зависимости от необходимого функционала \r\n// // console.dir(wrapper);\r\n// wrapper.addEventListener('click', (event) => {\r\n\r\n//     //тут мы вешаем обработчкик на новые кнопки с классом red\r\n//     //которые мы создаем ниже\r\n//     if (event.target && event.target.matches(\"button.red\")) {\r\n//         console.log('Hello');\r\n//     }\r\n//     // if (event.target && event.target.tagName == \"BUTTON\") {\r\n//     //     console.log('Hello');\r\n//     // }\r\n//     // if (event.target && event.target.classList.contains('some')) {\r\n//     //     console.log('Hello BLUE');\r\n//     // }\r\n//     // if (event.target && event.target.tagName == \"DIV\") {\r\n//     //     console.log('Hello DIV!!');\r\n//     // }\r\n// });\r\n// // Тут делегирование не работает - новые элементы не будут получать\r\n// //этот же класс который вешается для всех остальных кнопок.\r\n// // btns.forEach(btn => {\r\n// //     btn.addEventListener('click', () => {\r\n// //         console.log('Hello');\r\n// //     });\r\n// // });\r\n// const btn = document.createElement('button');\r\n// btn.classList.add('red');\r\n// wrapper.append(btn);\r\n\r\n\r\n// Временные скрипты \r\n//  Этот скрипт вставляет в верстку таймер с обратным отсчетом\r\n\t//Timer\r\n\r\n//     const deadline = '2021-12-19';\r\n\r\n//     function getTimeRemaining(endtime) {\r\n//         const t = Date.parse(endtime) - Date.parse(new Date()),\r\n//         //находит целое кол-во дней для таймера, остаток неполного дня отбрасывает\r\n//               days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n//               //находит кол-во часов для таймера, остаток в виде целых дней и секунд отбрасывает\r\n//               hours = Math.floor((t / (1000 * 60 * 60) % 24)),\r\n//               //остаток только минут\r\n//               minutes = Math.floor((t / 1000 / 60) % 60),\r\n//               seconds = Math.floor((t / 1000) % 60);\r\n\r\n//         return {\r\n//             'total': t,\r\n//             'days': days,\r\n//             'hours': hours,\r\n//             'minutes': minutes,\r\n//             'seconds': seconds\r\n//         };\r\n//     }\r\n\r\n//     function getZero(num) {\r\n//         if (num >= 0 && num < 10) {\r\n//             return `0${num}`;\r\n//         } else {\r\n//             return num;\r\n//         }\r\n//     }\r\n\r\n//     function setClock(selector, endtime) {\r\n//         const timer = document.querySelector(selector),\r\n//               days = timer.querySelector('#days'),\r\n//               hours = timer.querySelector('#hours'),\r\n//               minutes = timer.querySelector('#minutes'),\r\n//               seconds = timer.querySelector('#seconds'),\r\n//               timeInterval = setInterval(updateClock, 1000);\r\n\r\n//         updateClock();\r\n\r\n//         function updateClock() {\r\n//             const t = getTimeRemaining(endtime);\r\n\r\n//             days.innerHTML = getZero(t.days);\r\n//             hours.innerHTML = getZero(t.hours);\r\n//             minutes.innerHTML = getZero(t.minutes);\r\n//             seconds.innerHTML = getZero(t.seconds);\r\n\r\n//             if (t.total <= 0) {\r\n//                 clearInterval(timeInterval);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     setClock ('.timer', deadline)\r\n// });\r\n\r\n\r\n//Функции-конструкторы\r\n//Нужны для создания различных по св-вам но одинаковым по шлаблону обьектов\r\n// function User(name, id) {           \r\n//     this.name = name;\r\n//     this.id = id;\r\n//     this.human = true;\r\n//     this.hello = function() {\r\n//         console.log(\"Hello! \" + this.name);\r\n//     };\r\n   \r\n// }\r\n\r\n// User.prototype.exit = function() {\r\n//     console.log(`Пользователь ${this.name} ушел` );\r\n// };\r\n\r\n// let ivan = new User('Ivan', 28);    // 4)\r\n// let alex = new User ('Alex', 20);\r\n\r\n// ivan.exit();\r\n// ivan.hello();\r\n// alex.hello();\r\n\r\n\r\n//Контекст вызова This\r\n\r\n// 'use st rict'\r\n// function showThis(a, b) {    //1)\r\n//     console.log(this);\r\n//     function sum() {\r\n//         console.log(this);\r\n//         return a + b;\r\n//     }\r\n//     console.log(sum());\r\n// }\r\n// showThis(4, 5);\r\n\r\n\r\n// const obj = {   //2)\r\n//     a: 20,\r\n//     b: 15,\r\n//     sum: function() {\r\n//         //!!! функция ,которая запускается внутри метода, теряет контекст вызова\r\n//         function shout() {\r\n//             console.log(this);\r\n//         }\r\n//         shout();\r\n//     }\r\n// };\r\n// obj.sum();\r\n\r\n// function sayName(surname) {\r\n//     console.log(this);\r\n//     console.log(this.name + surname);\r\n// }\r\n\r\n// const user = {\r\n//     name: 'John'\r\n// }\r\n\r\n// sayName.call(user, 'Smith');\r\n// sayName.apply(user, ['Smith']);\r\n\r\n// function count(num) {\r\n//     return this*num;\r\n// }\r\n// // .bind создает новую функцию на основании сущ-ей функции \r\n// const double = count.bind(2);\r\n// console.log(double(3));\r\n// console.log(double(13));\r\n\r\n// 1) Обычная функция: this = window, но если use strict - undefined\r\n// 2) Контекст у методов обьекта - сам обьект\r\n//  Если мы исползуем метод внутри обьекта,\r\n//  то контекст вызова всегда будет сслыаться на этот обьект\r\n// 3) this в конструкторах и классах - новый экземпляр обьекта\r\n//  Внутри функций-конструкторов контекстом вызова для всех методов \r\n//  и св-в будет только что созданный новый обьект\r\n// 4) Ручная привзяка this:  call, apply, bind\r\n\r\n// const btn = document.querySelectorAll('button');\r\n\r\n// btn.forEach(item => {\r\n//     //в случае ображения к обьекту через коллбэк функцию обычного\r\n//     // формата( не стрелочную!!! =>), контекстом вызова будет являться \r\n//     // изначальный обьект, у стрелочной функции нет констекста вызова, \r\n//     // она будет брать его у родительского элемента\r\n//     item.addEventListener('click', function() {\r\n//         console.log(this);\r\n//         this.style.backgroundColor = 'red';\r\n//     });\r\n//     //ИЛИ\r\n//     // item.addEventListener('click',(e) => {\r\n//     //     e.target.style.backgroundColor = 'red';\r\n//     // });\r\n// }); \r\n\r\n\r\n// const obj = {\r\n//     num: 5, \r\n//     sayNumber: function() {\r\n//         const say = () => {\r\n//             console.log(this.num);\r\n//         };\r\n//         say();\r\n//     }\r\n// };\r\n// obj.sayNumber();\r\n\r\n\r\n//КЛАССЫ ES6\r\n \r\n// class Rectangle {\r\n//     //конструктор вызывается как только создается обьект класса \r\n//     constructor(height, width) {\r\n//         this.height = height;\r\n//         this.width = width;\r\n//     }\r\n\r\n//     calcArea() {\r\n//         return this.height * this.width;\r\n//     }\r\n// }\r\n\r\n// class ColoredRectangWithText extends Rectangle {\r\n//     constructor(height, width, text, bgColor) {\r\n// //Метод super НАСЛЕДУЕТ указанный функционал от того класса, который мы наследуем\r\n//         super(height, width);\r\n//         this.text = text;\r\n//         this.bgColor = bgColor;\r\n//     }\r\n//     showMyProps() {\r\n//         console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);\r\n//     }\r\n// }\r\n\r\n// const div = new ColoredRectangWithText(25, 10, \"Hello World\", 'red');\r\n\r\n// div.showMyProps();\r\n// console.log(div.calcArea());\r\n\r\n\r\n\r\n// // REST operator ES6 - отдельные элементы обьединяет в один массив\r\n\r\n// const log = function (a, b ,...rest){\r\n//     //...rest - собирает отдельные сущности в массив\r\n//     console.log(a, b, rest);\r\n// }\r\n// log('basic', 'rest', 'operator', 'usage');\r\n\r\n// function calcOrDouble(number, basis = 2) {\r\n//     console.log(number * basis);\r\n// }\r\n\r\n// calcOrDouble(3);\r\n\r\n\r\n//JSON формат передачи данных\r\n\r\n// const persone = {\r\n//     name: 'Alex',\r\n//     tel : '+7413332321',\r\n//     parents: {\r\n//         mom: 'Olga',\r\n//         dad: 'Mike'\r\n//     }\r\n// };\r\n// //JSON.stringify преобразует данные в нужный  для браузера формат\r\n// //JSON.parse - разбирает формат JSON в нормальный код\r\n\r\n// //с помощью конструкции JSON.parse(JSON.stringify()) можно делать глубокое клонирование\r\n// // обьектов в js. Где будут копироваться и вложенные обьекты \r\n// const clone = JSON.parse(JSON.stringify(persone));\r\n// clone.parents.mom = 'Ann';\r\n// console.log(persone);\r\n// console.log(clone);\r\n\r\n\r\n// //XMLHttpRequest\r\n// const inputRub = document.querySelector('#rub');\r\n// const inputUsd = document.querySelector('#usd');\r\n\r\n// inputRub.addEventListener('input', () => {\r\n//     const request = new XMLHttpRequest();\r\n//     //МЕТОДЫ ОБЬЕКТА XMLHttpRequest\r\n//     // этот метод собирает настройки которые помогут сделать запрос\r\n//     request.open('GET', 'js/current.json');\r\n//     request.setRequestHeader('Content-type', 'application/json; charset=utf-8');\r\n//     request.send();//body\r\n\r\n//     //readystatechange - отслеживает статус нашего запросса (readySstate) в текущий момент\r\n\t\r\n//     request.addEventListener('load', () => {\r\n//         //если у нас статус 4(Done) и статус ответа 200 \r\n//         if (request.status === 200) {\r\n//             // console.log(request.response);\r\n//             const data = JSON.parse(request.response);\r\n//             inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2);\r\n//         } else {\r\n//             inputUsd.value = 'Error';\r\n//         }\r\n//     });\r\n//     // status: ответы в кодах от сервера\r\n//     // statusText\r\n//     // response - ответ от сервера \r\n//     // responceText\r\n//     // readySstate - содержит текущее состояние запроса (0-4)\r\n// });\r\n\r\n\r\n//PROMISE в JS\r\n//может выполнять последовательность действий, если произошли определенные условия\r\n\r\n// console.log('Запрос данных...');\r\n\r\n// const req = new Promise(function(resolve, reject) {\r\n\r\n// \tsetTimeout(() => {\r\n// \t\tconsole.log('Подготовка данных...');\r\n\r\n// \t\tconst product = {\r\n// \t\t\tname: 'TV',\r\n// \t\t\tprice: 2000\r\n// \t\t};\r\n//  \t //эта функция запустится только если код вверху корректно отработал \t\t\r\n// \t\tresolve(product);\r\n// \t}, 2000);\r\n// });\r\n// //then отработает в случае удачного выполнения промиса\r\n// req.then((product) => {\r\n// \tconst req2 = new Promise((resolve, reject) => {\r\n// \t\tsetTimeout(() => {\r\n// \t\t\tproduct.status = 'order';\r\n// \t\t\tresolve(product);\r\n// \t\t\t// reject();\r\n// \t\t}, 2000);\r\n// \t});\t\r\n// \t// при выполнении кода вызывается resolve, который обьявляется дальше в - then\r\n// \t// при не выполнении кода(ошибке) вызывается reject, который обьявляется дальше в - catch\r\n// }).then(data => {\r\n// \tdata.modify = true;\r\n// \treturn data;\r\n// }).then(data => {\r\n// \tconsole.log(data);\r\n// \t// .catch(() => {})\r\n// }).catch(() => {\r\n// \tconsole.error('Произошла ошибка');\r\n// \t// .finally(() => {}); - выполняется всегда, вне зависимости от исхода кода\r\n// }).finally(() => {\r\n// \tconsole.log('Finally');\r\n// });\r\n// //этот setTimeout запустится только если код вверху корректно отработал \r\n\r\n// const test = time => {\r\n// \treturn new Promise(resolve => {\r\n// \t\tsetTimeout(() => resolve(), time);\r\n// \t});\r\n// };\r\n\r\n// // Promise.all - отрабатывает только когда все промисы до этого отработали, \r\n// // если все корректно прошли - отработает .then(), если нет - .catch() \r\n// Promise.all([test(1000), test(2000)]).then(() => {\r\n// \tconsole.log('All');\r\n// });\r\n\r\n// // Promise.race - отрабатывает  когда самый первый промис отработал.\r\n// Promise.race([test(1000), test(2000)]).then(() => {\r\n// \tconsole.log('All');\r\n// });\r\n\r\n\r\n// МЕТОДЫ ПЕРЕБОРА МАССИВОВ\r\n\r\n//forEach -  перебирает массив, но не возвращает новый массив\r\n\r\n//filter - возвращает новый массив отфильтрованный по функции\r\n// const names = [\"Ivan\", \"Ann\", \"Ksenia\", \"Voldemart\"];\r\n\r\n// const shortNames = names.filter(function(name){\r\n// \treturn name.length < 5;\r\n// });\r\n\r\n// console.log (shortNames);\r\n\r\n// //map - позволяет взять исходный массив и изменить каждый элемент внутри него.\r\n// // Мы получим новый массив с измененными данными\r\n// const answers = ['IvAn', 'AnnA', 'HellO'];\r\n// const result = answers.map(item => item.toLowerCase());\r\n// // let answers1 = ['IvAn', 'AnnA', 'HellO'];\r\n// // answers1 = answers1.map(item => item.toLowerCase());\r\n// console.log (answers);\r\n// console.log (result);\r\n\r\n// //every - перебирает массив, если все элементы подходят по \r\n// // условию колбэк функции, возращает - true, если же нет - false\r\n\r\n// //some - перебирает массив, если ходя бы один элемент подходит по \r\n// // условию колбэк функции, возращает - true, если же нет - false\r\n// const someThing = [4, 'qwq', 'stersdf4'];\r\n// console.log(someThing.some(item => typeof(item) === 'number'));\r\n\r\n// console.log(someThing.every(item => typeof(item) === 'number'));\r\n\r\n// // reduce - схопывает массив в одно единое целое (метод перебора каждого элемента)\r\n// const nubmers = [4, 5, 1, 3, 2, 6];\r\n// // \t\t\t 0 + 4\r\n// // \t\t\t\t 4 +5\r\n// // \t\t\t\t\t5 +1\r\n// //если поставить после запятой элемент - он будет начальным при сложении\r\n// const res = nubmers.reduce((sum, current) => sum + current, 3);\r\n// console.log(res);\r\n// // text fields\r\n// const fruits = ['apple', 'cherry', 'strawberry'];\r\n// const fruitBag = fruits.reduce((sum, current) => `${sum}, ${current}`);\r\n// console.log(fruitBag);\r\n\r\n\r\n// //нужно вытащить имена людей отсюда\r\n// const obj = {\r\n// \tivan: 'persone',\r\n// \tann: 'persone',\r\n// \tdog: 'animal',\r\n// \tcat: 'animal'\r\n// };\r\n\r\n// //делает из обьекта матрицу, содержащую массивы\r\n// const newArr = Object.entries(obj)\r\n// //фильтрует и созает новый массив подходящих массивов по ключу \"persone\" \r\n// .filter(item => item[1] === 'persone')\r\n// //выводит первые элементы (имена) из уже вновь созданного массива.\r\n// .map(item => item[0]);\r\n\r\n// console.log(newArr);\r\n\r\n\r\n// LOCAL STORAGE - это обьект, который встроен в браузеры. \r\n//  И он может хранить различеные данные. \r\n// Обьект существуют в рамках однго домена\r\n// и может хранить ограниченное кол-во данных(до 5 мб.) \r\n//данные не сбрасываются при перезагрузке\r\n\r\n// window.localStorage\r\n// console.log('working...');\r\n\r\n// localStorage.setItem('number', 5);\r\n\r\n// // localStorage.removeItem('number');\r\n// // localStorage.clear();\r\n// console.log(localStorage.getItem('number'));\r\n\r\n// const checkbox = document.querySelector('#checkbox'),\r\n// \t  form = document.querySelector('form'),\r\n// \t  change = document.querySelector('#color');\r\n\r\n// if (localStorage.getItem('isChecked')) {\r\n// \tcheckbox.checked = true;\r\n// \t// localStorage.removeItem('isChecked');\r\n// }\r\n// if (localStorage.getItem('bg') === 'changed') {\r\n// \tform.style.backgroundColor = 'red';\r\n// }\r\n\r\n// checkbox.addEventListener('change', () => {\r\n// \tlocalStorage.setItem('isChecked', true);\r\n// });\r\n\r\n\r\n// change.addEventListener('click', () => {\r\n// \tif (localStorage.getItem('bg') === 'changed') {\r\n// \t\tlocalStorage.removeItem('bg');\r\n// \t\tform.style.backgroundColor = 'white';\r\n// \t} else {\r\n// \t\tlocalStorage.setItem('bg', 'changed');\r\n// \t\tform.style.backgroundColor = 'red';\r\n// \t}\r\n// });\r\n\r\n// const persone = {\r\n// \tname: 'Alex',\r\n// \tage: 25\r\n// };\r\n\r\n// const serializedPersone = JSON.stringify(persone);\r\n// localStorage.setItem('alex', serializedPersone);\r\n\r\n// console.log(JSON.parse(localStorage.getItem('alex')));\r\n\r\n// REGULAR EXPRESSIONS - РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ\r\n// const ans = prompt('Enter your name');\r\n\r\n// const reg = /\\d/;\r\n// console.log(ans.match(reg));\r\n\r\n\r\n// const str = 'My name is R2D2';\r\n\r\n// console.log(str.match(/\\W/i));\r\n//Классические флаги регулярных выражений:\r\n// i - если мы хотим найти что-то вне зависимости от регистра\r\n// g - когда  мы хотим попробовать найти сразу несколько вхождений\r\n// m - включает многострочный режим\r\n\r\n// КЛАССЫ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ\r\n\t// \\d - мы ищем только цифры\r\n\t// \\w - мы ищем все слова\r\n\t// \\s - мы ищем только пробелы\r\n\r\n// ОБРАТНЫЕ КЛАССЫ \r\n\t// \\D - найти все не числа\r\n\t// \\W - найти все не буквы\r\n\r\n// МЕТОДЫ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ\r\n// метод: test относится непосредственно к регуляркам,\r\n//  и работает только с ними. Выдает true или false\r\n// метод: search ищет первое вхождение в строке и возвращает логический ответ\r\n// метод: match ищет первое вхождение в строке и возвращает массив\r\n\r\n// такая запись значит - \"/./\" что мы забираем все символы из строки\r\n// это значит /\\./ - мы экранируем символы с помощью \"\\\"  \r\n\r\n// console.log(ans.search(reg));\r\n// const pass = prompt('Password');\r\n// console.log(pass.replace(/./g,  \"*\"));\r\n// console.log(\"12-34-56\".replace(/-/g,  \":\")); \r\n\r\n\r\n// ГЕТТЕРЫ и СЕТТЕРЫ(свойства обьектов)\r\n\r\n// const persone = {\r\n// \tname: \"Alex\",\r\n// \tage: 24,\r\n\r\n// \t// get позволяет получить значение свойсвта этого обьекта\r\n// \tget userAge() {\r\n// \t\treturn this.age;\r\n// \t},\r\n// \t// set позволяет получить изменить свойсвто этого обьекта\r\n// \tset userAge(num) {\r\n// \t\tthis.age = num;\r\n// \t}\r\n// };\r\n\r\n// console.log(persone.userAge);\r\n// console.log(persone.userAge = 33);\r\n\r\n\r\n// ИНКАПСУЛЯЦИЯ\r\n\r\n// class User {\r\n// \tconstructor(name, age) {\r\n// \t\tthis.name = name;\r\n// \t\t//ниже мы создаем свойство обьекта, которое нельзя изменить извне\r\n// \t\tthis._age = age;\r\n// \t}\r\n\r\n// \t#surname = 'PEPE';\r\n\r\n// \tget surName() {\r\n// \t\treturn this.#surname;\r\n// \t}\r\n// \tset surnameSet(surname) {\r\n// \t\tthis.#surname = surname;\r\n// \t}\r\n\r\n// \tsay() {\r\n// \t\tconsole.log(`This user name: ${this.name} ${this.#surname}, age: ${this._age}`);\r\n// \t}\r\n// \t//c помощью геттеров и сеттеров мы закрыли доступ к изменению извне\r\n// \tget age() {\r\n// \t\treturn this._age;\r\n// \t}\r\n\r\n// \tset age (age) {\r\n// \t\tif (typeof age === 'number' && age > 0 && age < 110) {\r\n// \t\t\tthis._age = age;\r\n// \t\t} else {\r\n// \t\t\tconsole.log('Недопустимое значение');\r\n// \t\t}\r\n// \t}\r\n// }\r\n\r\n// const ivan = new User('Ivan', 27);\r\n\r\n// console.log(ivan.surName); \r\n// ivan.surnameSet ='POPO';\r\n// console.log(ivan.surName); \r\n\r\n// ivan.say();\r\n\r\n\r\n// Прием \"МОДУЛЬ\"\r\n\r\n// const number = 1;\r\n\r\n// //function declaration - для обьявления функции необходимо имя\r\n// // function ( ) {};\r\n\r\n// //анонимная самовызывающаяся функция:\r\n\r\n// (function() { // - function expression\r\n\r\n// \t// это позволяет уменьшить количество глобальных переменных, что улучшает кач-во кода \r\n// \tconst number = 2;\r\n// \tconsole.log (number);\r\n// \tconsole.log (number + 3 );\r\n// }());\r\n\r\n// console.log(number);\r\n\r\n// const user = (function(){ \r\n// \t//мы создаем анонимную самовызывающуюся ф-ию, которая забирает методы и свойства,\r\n// \t// которые мы укажем, и которые нам нужны\r\n// \tconst privat = function() {\r\n// \t\tconsole.log('I am privat!');\r\n// \t};\r\n// \treturn {\r\n// \t//здесь мы констркируем новый обьект, в который передаем ссылку на приватную ф-ию\r\n// \t\tsayHello: privat\t\r\n// \t};\r\n// }());\r\n\r\n// user.sayHello();\r\n\r\n\r\n//GULP - планировщик задач, \r\n// мы можем создавать различные таски, выполняемые в оп. обстоятельствах\r\n\r\n//WEBPACK - сборщик модулей, может запускаться с помощью GULP \r\n\r\n// function myModule() {\r\n// \tthis.hello = function() {\r\n// \t\tconsole.log('hello');\r\n// \t};\r\n\r\n// \tthis.goodbye = function() {\r\n// \t\tconsole.log('bye!');\r\n// \t};\r\n// }\r\n\r\n//CommonJs =- так экспортируются файлы\r\n// module.exports = myModule;\r\n\r\n//ES6 - так экспортируются файлы\r\n\r\n//именованный экспорт\r\nexport let one = 1;\r\n\r\nlet two = 2;\r\n\r\nexport{two};\r\n\r\nexport function sayHi(){\r\n\tconsole.log('Hello');\r\n}\r\n\r\n//Экспорт по умолчанию должен быть только один\r\nexport default function sayHiDef() {\r\n\tconsole.log('Hello Default');\r\n}\r\n\r\n// можно в индексе подключать модулями файлы js, но нужно настраивать экспорты и полностью прописывать пути.\r\n// <script type='module' src=\"./dist/js/bundle.js\"></script>\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//импорт из module.exports = myModule;\r\n// const myModule = requre('../src/js/main.js');\r\n// const myModuleInstatce = new myModule();\r\n\r\n// myModuleInstatce.hello();\r\n// myModuleInstatce.goodbye();\r\n\r\n\r\n//импорт из ES6 для именнованного экспорта(где можно менять имя эксплртируемых переменных)\r\n// import { one as first, two } from \"./main\";\r\nimport * as data from \"./main\";\r\n\r\n// console.log(`${first} and ${two}`);\r\nconsole.log(`${data.one} and ${data.two}`);\r\ndata.sayHi();\r\n\r\n//неименнованный экспорт\r\nimport sayHiDef from \"./main\";\r\nsayHiDef();"],"names":[],"sourceRoot":""}